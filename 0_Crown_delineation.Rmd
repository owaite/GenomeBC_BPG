# Crown delineation {#crown-delineation}

We are using supercells to create delineated crowns using:

1) A shapefile (.shp) with a grid of tree locations derived by georeferencing the census data to the imagery. This will be referred to as the “grid”. Detailed steps for creating the grid can be found in chapter \@ref(Georeferencing-Plot-Trees).

2) Co-registered CHM made from normalized maximum elevation (Z) values, MicaSense orthomosaic, and P1 orthomosaic, ideally from around the same date. 

The R code contains commented sections where manual editing in a GIS is required. Below steps starting with (R) are steps done in the R code and (GIS) are steps requiring editing in a GIS such as QGIS or ArcGIS. The R code does the following: 

- (R) The grid treetop points are buffered by 30-40cm, and using the CHM, the grid is snapped to the maximum value within this circle. 

- (GIS) Check the location of the treetops to the P1 orthomosaic and manual move treetops to align with trees in the P1 orthomosaic where necessary. 

- (R) Load in manually edited treetops, create circles proportional to tree height. 

- (R) Create a supercell segmentation raster using the CHM and MicaSense and P1 orthomosaics 

- (R) Filter out segments that do not touch any of the circles proportional to tree height 

- (R) Merge remaining segments to create crown polygons 

- (GIS) Load into a GIS, along with the edited treetops and P1 orthomosaic, and edit the crown polygons to remove sections where neighbouring branches intersect the crown to ensure the crowns contain only data from the correct tree.  Obscured trees are given a crown confidence score and can be removed at analysis.  This is the most manually time-consuming process in the whole project.    


Once we have a grid that contains a point for every tree we would like to make a crown for we can move onto the next step

## Circles Proportional to Tree Height. 

The following code takes the grid and a registered CHM and creates a circle around each grid point that is proportional to a defined percent of its height. The percent will be dependent on the size and spacing of the plot trees.

In this example we decided to use 10% given the tight spacing and areas of crown closure. We recommend trying a range of percentages and choosing the one that gives proportional circles that contain as much of the visible portion of the crown as possible without also catching neighbouring branches.

Depending on the project, circles proportional to height may serve as adequate tree crowns, however if not these circles will be used later in this workflow to filter the supercells for more defined crown boundaries. 


```{r, eval=FALSE, echo=TRUE}
unique_id <- "treeID" # change this to the unique ID you have per tree that was used to create the grid
crown_dir <- paste0("path to save crown delineation producst to")# This was a path to a folder called Crowns for us

ttops <- st_read("path to your grid")# read in the treetops as an sp object
ttops<- ttops%>%
  st_centroid()

# Buffering circles around grid points to get heights for each tree:
buffer_radius <- 0.1  # buffer radius in meters
ttops_buffered <- st_buffer(ttops, dist = buffer_radius)# Create a buffer around each centroid with a radius of 10cm (0.1 meters)

#Check geometries, this should be  = 0
sum(!st_is_valid(ttops_buffered))

ttops_buffered <- ttops_buffered[!st_is_empty(ttops_buffered), ]

# Height Quantile from CHM
CHM_L1 <- "path to CHM" #path to CHM
CHM_max_L1 <- rast(CHM_L1) #read in CHM as a raster

extracted_values = ttops_buffered %>% #extract height percentiles
  exact_extract(x = CHM_max_L1,
                y = .,
                fun = "quantile",
                quantiles = c(0.975, 0.99),
                force_df = TRUE,
                append_cols = c(unique_id)) 

ttops_zq99 <- left_join(ttops_buffered, extracted_values, by = c(unique_id)) # Assign the pixel IDs to each polygon

# Saving out shp of buffered points
if(!dir.exists(paste0(crown_dir,"Buffer_radius_ttops_",buffer_radius))){
  dir.create(paste0(crown_dir,"Buffer_radius_ttops_",buffer_radius))
}
st_write(ttops_zq99, paste0(crown_dir,"Buffer_radius_ttops_",buffer_radius,"\\",site,"_ttops_",buffer_radius,"mBuffers_.shp"), append = FALSE)

# Proportional hulls based on 10% of the 99th percentile height value
percent <- 10
(buffer_dist <- ttops_zq99$q99 * (percent/100)/2)

buffer_dist[is.na(buffer_dist)] <- 0 

prop_hulls <- ttops_zq99%>%
  st_as_sf(crs = 26910)%>% #change to match your CRS
  st_buffer(dist = buffer_dist)%>% #value here is the radius
  mutate(buff = buffer_dist)

(prop_hulls$crownArea <- st_area(prop_hulls))

#Below we remove columns with mainly NAs as they will cause errors for the segmentation raster
prop_hulls_forSEG <- prop_hulls %>%
  dplyr::select(c(TAG, row, col, q99, q97, crownArea)) #select columns you would like to keep in your crown shapefile, if the columns contain NA values, remove them for the following segmentation steps and re-join the columns at the end


st_write(prop_hulls_forSEG, paste0(crown_dir,"Buffer_radius_ttops_",buffer_radius,"\\",site,"_proportional_Hulls_Diam",percent,"percent_zq99_forSEG_.shp"), append = FALSE) #Save shapefile of circles proportional to height for each tree
```

See Figure @\ref(fig:prop-circle-crowns) below for an example of the above output.

```{r prop-circle-crowns, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "Red circles proprotional to height for each plot tree, with grid points representing the top of the plot trees shown in blue. This data has been overlain on a P1 orthomosaic."}
knitr::include_graphics(here("Photos_&_gifs\\prop_cirlce_Crowndelin.PNG"))
```

## Supercell Raster

[Supercells](https://jakubnowosad.com/supercells/) work to spatially group pixels with similar characteristics making it a great tool for crown delineation. To generate supercells, we use a Canopy Height Model (CHM), MicaSense orthomosaic, and P1 orthomosaic. When possible we provide rasters from the same flight date. However, if that is not feasible we select a CHM, MicaSense, and P1 orthomosaic from flight acquisitions flown as closely together as possible. This ensures that the aerial perspectives of the tree crowns remain highly consistent across the three rasters, facilitating more accurate supercell segmentation.

```{r, eval=FALSE, echo=TRUE}
library(future) 
library(supercells)
library(RStoolbox)

crown_dir_folder <- "directory to save files to" #change to match yours
ms_path <- "path to MicaSense orthomosaic"
p1_path <- "path to P1"
prop_hulls <- prop_hulls_forSEG #created in the step above

Hulls = prop_hulls

bound = Hulls %>% #buffer hulls by 5m to get a bounding box to trim rasters with
  st_buffer(5)

# Reading in CHM, MS, and P1 rasters to make supercells
CHM_max_L1 = rast(CHM_L1) %>%
  crop(bound) %>%
  trim()
ms_ortho = rast(ms_path)[[c(1,6,9)]] %>% 
  resample(CHM_max_L1, method = "near") %>% 
  crop(bound)%>%
  trim
rgb = rast(p1_path)[[1:3]] %>% 
  resample(CHM_max_L1,method = "near") %>% 
  crop(bound) %>%
  trim

# Ensure crs match between rasters prior to stacking
crs(ms_ortho) <- crs(CHM_max_L1) 
crs(rgb)<- crs(CHM_max_L1) 
crs(CHM_max_L1) == crs(ms_ortho)

use = c( # Creating a SpatRaster, crs must match for this step
  CHM_max_L1,
  ms_ortho,
  rgb)

use[use > 60000] = NA # Filtering out noisy data

use2 = terra::scale(use)

writeRaster(use2, paste0(crown_dir_folder,"scaled_for_segments.tif"),
            overwrite = TRUE)

use3 = use2 %>% 
  ifel(CHM_max_L1 < .25 , 
       NA, .)

plan(multisession, workers = 6L)

seg = supercells(use3, step = 6, compactness = 5, iter = 50)

if(!dir.exists(paste0(crown_dir_folder,"HULLS"))){ #creating "HULLS" folder to save the below supercell .shp to
  dir.create(paste0(crown_dir_folder,"HULLS"))
}
st_write(obj = dplyr::select(seg, supercells, geometry), 
         dsn = paste0(crown_dir_folder,"HULLS\\",site,"_SEGS_step6_c5.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)
```

Figure @\ref(fig:seg-parts) shows the supercells in green created by the above R code. These outlined areas indicate groups of pixels that the supercell algorithm has deemed similar between the CHM, MicaSense and P1 orthomosaics.


```{r seg-parts, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "Supercells shown in green, with circles proportional to the 99th height percentile in red and grid points representing plot trees in blue"}
knitr::include_graphics(here("Photos_&_gifs\\seg_Crowndelin.PNG"))
```

## Filter & Merge Supercells

Above we found supercells across the site however now we need to filter for supercells that belong to tree crowns only. We do this by using the previously made circles proportional to height, where supercells must be within the circle or intersect the perimeter in order to be kept, see Figure @\ref(fig:seg-intersection) for a visual.
```{r, eval=FALSE, echo=TRUE}
library(smoothr) #for fill_holes
#Creating a folder to save files to, this was set up so that multiple tests could be run with different "percent" values 
if(!dir.exists(paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99"))){
  dir.create(paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99"))
}

chm_dat = c(CHM_max_L1)
names(chm_dat) = c("CHM_max_L1")

seg_extract = seg %>% 
  exact_extract(x = chm_dat,
                y = .,
                fun = "max",
                force_df = TRUE,
                append_cols = c("supercells"))

class(seg_extract)

seg1 = st_join(seg, prop_hulls_forSEG) %>% 
  drop_na() %>% 
  group_by(supercells) %>% 
  mutate(count = n()) %>% 
  left_join(seg_extract, by = c("supercells"))

saveRDS(seg1, paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEG_intersection.rds"))

st_write(obj = seg1, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEG_intersection.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

```


```{r seg-intersection, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_intersection_Crowndelin.PNG"))
```
A further filter that can be used is filtering out supercells that overlap areas on the CHM that are under a certain height cutoff per tree. In our case, given that the trees are tightly spaced we are not concerned with capturing lower branches in our crowns as they will likely be either not visible due to occlusion or shadowed by neighbouring trees resulting in the removal of the shadowed pixels within the spectral data anyways. Thus we created circles that were proportional to 10% of the 99th percentile per tree. 

Hence further filtering with the 50% of the 99th height percentile, from the below R code, did not result in the removal of any supercells (Figure @\ref(fig:seg-initial)). This filtering step is mainly if you want to ensure you are only includnig data from above a certain height percentile in your crowns that was not already removed by the above filtering step using the proportional circles.

```{r, eval=FALSE, echo=TRUE}
seg2 = seg1 %>% 
  mutate(z50_L2 = q99 * .5) %>% #filtering out supercells where the CHM value in that super cell as less than 50% of the 99th percentile (~50th height percentile)
  mutate(TAG_archive = TAG,
    TAG = if_else(
    max > z50_L2, #&
    # max.CHM_max_L2 > z50_L2,
    TAG, 0)) %>% 
  group_by(supercells) %>% 
  mutate(count = n()) %>% 
  mutate(TAG = if_else(count > 1, 0, TAG))


st_write(obj = seg2, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEGS_initial.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

dim(seg2)       

```


```{r seg-initial, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_initial_Crowndelin.PNG"))
```


```{r seg-centroids, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_centroids_Crowndelin.PNG"))
```

```{r seg-keep, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_keep_outline_Crowndelin.PNG"))
```


```{r seg-merge, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_merge_Crowndelin.PNG"))
```

```{r seg-merge-smooth, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_merge_smooth_Crowndelin.PNG"))
```


```{r seg-merge-smooth-np, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_merge_smooth_NMP_Crowndelin.PNG"))
```


```{r, eval=FALSE, echo=TRUE}

seg3 = seg2 %>% 
  filter(TAG != 0) %>% 
  st_centroid() %>% 
  st_join(y = prop_hulls_forSEG, join = st_within) %>% 
  drop_na() %>% 
  dplyr::select(supercells, geometry)

st_write(obj = seg3, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEGS_centroids.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

plot(seg3)

seg4 = seg2 %>% 
  st_join(seg3) %>% 
  drop_na() 

seg5 = seg4 %>% 
  group_by(TAG) %>% 
  summarise()

plot(seg5)

st_write(obj = seg4, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEGS_keep.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

st_write(obj = seg5, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEGS_merge.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

seg5_smooth <- seg5 %>% 
  fill_holes(threshold = units::set_units(2000, "cm^2"))

## CHECK:
# test_tree <- seg5_smooth %>%
#   filter(TAG_filtered == 664)
# plot(test_tree$geometry, col = "red")

st_write(obj = seg5_smooth, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\SEGS_merge_smooth.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

unique(st_geometry_type(seg5_smooth))

seg5_smooth_NM <- st_cast(seg5_smooth, "POLYGON")
# 
unique(st_geometry_type(seg5_smooth_NM)) # should only have "Polygon" no more multipolygons

st_write(obj = seg5_smooth_NM, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\HULLS\\SEGS_merge_smooth_NoMultipolygon.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)

## adding in attributes back
att <- ttops %>%
  as.data.frame()%>%
  dplyr::select(-c(geometry))

(seg5_smooth_NM_attributes <- left_join(seg5_smooth_NM,att, by = unique_id ))

st_write(obj = seg5_smooth_NM_attributes, 
         dsn = paste0(crown_dir_folder,"Prop_Diameter",percent,"%OfZq99\\HULLS\\SEGS_merge_smooth_NoMultipolygon_Attributes.shp"),
         driver = "ESRI Shapefile",
         append = FALSE)


```

## Manually Edite Crowns

```{r crown-seg, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_crowns_Crowndelin.PNG"))
```

```{r crown-circ, echo=FALSE,fig.align = 'center',out.width="100%", fig.cap= "                 "}
knitr::include_graphics(here("Photos_&_gifs\\seg_crowns_w_propcircles_Crowndelin.PNG"))
```



```{r, eval=FALSE, echo=TRUE}

```



<!-- ```{r 2-delin-crowns, echo=FALSE,fig.align = 'center',out.width="60%", fig.cap= "Delineated crowns at Bit Tree Creek with partially obscured plot trees in purple."} -->
<!-- knitr::include_graphics(here("Photos_&_gifs\\crowns.PNG")) -->
<!-- ``` -->